#!/usr/bin/env ruby
require 'pry'

module Point
  # Allows an object to be positioned on a plane.
  module InstanceMethods
    attr_accessor :x, :y

    def to_array
      [x, y]
    end

    alias to_a to_array
  end
end

class Position
  include Point::InstanceMethods
  def initialize(options={x: 0, y: 0})
    @x = Integer(options[:x])
    @y = Integer(options[:y])
  end

  def change(direction)
    case direction
    when 'N'
      self.class.new(x: x, y: y + 1)
    when 'W'
      self.class.new(x: x - 1, y: y)
    when 'S'
      self.class.new(x: x, y: y - 1)
    when 'E'
      self.class.new(x: x + 1, y: y)
    end
  end

  # @return [Hash] Converts options object to an options hash. All keys
  #   will be symbolized.
  def to_hash
    { x: x, y: y }
  end

  alias to_h to_hash

  # Inspects the object
  def inspect
    "<#{self.class} #{{ x: @x, y: @y }}>"
  end
end

class Mower
  def initialize(options={x: 0, y: 0, o: 'N'}, lawn)
    @position  = Position.new(options)
    @direction = nil
  end

  def perform!(instructions)
  end

  # Inspects the object
  def inspect
    "<#{self.class}>"
  end
end

class Lawn
  def initialize(x,y)
  end

  # Inspects the object
  def inspect
    "<#{self.class}>"
  end
end

class Parser
  attr_accessor :output
  COMMANDS = %w{L R F}
  DIRECTIONS = %w{N E W S}

  def initialize(input)
    @input = input.strip
    @output = "" # The output
    validate!
    parse!
  end

  private
  def parse!
    # Valid directions & commmands
    code = @input.lines
    x, y = code.shift
    lawn = Lawn.new(x,y)
    lines = ["1 3 N", "5 1 E"] # Line results (tmp)
    keys = [:x,:y,:o]
    code.each_slice(2) do |pair|
      # Position and direction
      # Mower
      pos, instructions = pair.map(&:strip)
      h = keys.zip(pos.split(' ')).to_h
      mower = Mower.new(h, lawn)
      mower.perform!(instructions)
      @output += "#{lines.shift}\n"
    end
  end

  def validate!
    # Should contains at least 3 lines of code
    throw 'Invalid Format' if @input.lines.size < 2
    # Should contains an odd number of lines
    throw 'Invalid Format' if @input.lines.size%2==0
    # Should contains specific characters
    throw 'Invalid Format' if !@input.gsub(/\d+/,"").split.join
              .delete("#{(DIRECTIONS + COMMANDS).join}").empty?
  end

  # Inspects the object
  def inspect
    "<#{self.class} #{{ output: @output}}>"
  end
end

input = ARGV[0] || """
5 5
1 2 N
LFLFLFLFF
3 3 E
FFRFFRFRRF
"""

puts Parser.new(input).output
